[{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"test","slug":"test","date":"2022-03-28T02:49:54.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"0aaa27c48e7b40c2bc96b31fb70803da","title":"TypeScript","content":"TypeScriptTypeScript是由微软推出并推动的一个静态类型检查的编译型编程语言，可以完美兼容ES6的JavaScript。目前大量前端库和应用使用TS开发，已然成为前端的主流开发语言。\n优势\n静态编译，减少JS动态语言特性带来了的非常多的隐藏bug\n类型安全检查在编译阶段完成\n大型项目的更好的进行管理和向后约定维护\n为前端的彻底的静态安全的类型检查、类型继承、抽象设计体系铺好了基石\n更加友好的智能提示和文档说明\n\n安装TypeScript有两种主要的方式来获取TypeScript工具\n\n通过npm安装\n  npm install -g typescript\n\n安装Visual Studio的TypeScript插件\n\n\n编译代码启动编译后，可以添加-w参数，让编译工具一直监听文件的变化，ts文件变化后自动编译。\ntsc -w tyDemon.ts\n    or\ntsc --watch tyDemon.ts\n\n编译多个ts文件\n\n编译当前目录下的所有的ts文件\n  tsc -w *.ts\n\n\n编译当前目录及子目录的ts文件\n  tsc -w ./**/*.ts\n\n\n\n数据类型布尔值最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean\nlet isDone: boolean = false; \n// 冒号后面是对当前变量类型的声明，isDone只能赋值布尔类型值，否则会编译失败。\n\n数字和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ES5中引入的二进制和八进制字面量\nlet num1: number = 6;\nlet num2: number = 0xf00d;\nlet num3: number = 0b1010;\nlet num4: number = 0o744;\n\n字符串JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号&quot;或单引号&#39;表示字符串\nlet name: string = \"bob\";\nname = \"smith\";\n\n数组TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组\nlet list: number[] = [1, 2, 3];\nlet list: Array&lt;number> = [1, 2, 3];\n元祖元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\nlet x: [string, number];\nx = ['hello', 10]; // OK\nx = [10, 'hello']; // Error\n\nany有时候，会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量\nlet any1: any = 4;\nany1 = \"maybe a string instead\";\nany2 = false; \n\nvoid它表示没有任何类型。 当一个函数没有返回值时，会见到其返回值类型是void\nfunction fn(): void &#123;\n   console.log(\"This is message\");\n&#125;\n\n声明void变量只能给其赋值为null, undefined\nlet void1: void = undefined;\n\nNull 和 Undefinedundefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似。\nlet u: undefined = undefined;\nlet n: null = null;\n\nObjectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。\ndeclare function create(o: object | null): void;\n\ncreate(&#123; prop: 0 &#125;); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n\n枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予名字。\nenum Color &#123;Red, Green, Blue&#125;\nlet c: Color = Color.Green;\n默认情况下，从0开始为元素编号。 也可以手动的指定成员的数值。 例如，将上面的例子改成从 1开始编号：\nenum Color &#123;Red = 1, Green, Blue&#125;\nlet c: Color = Color.Green;\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，可以查找相应的名字\nenum Color &#123;Red = 1, Green, Blue&#125;\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示'Green'因为上面代码里它的值是2\n函数函数的声明 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单\n \tfunction sum(x: number, y: number): number &#123;\n    return x + y;\n\t&#125;\n输入多余的（或者少于要求的）参数，是不被允许的\n\n\tfunction sum(x: number, y: number): number &#123;\n    return x + y;\n\t&#125;\n\tsum(1, 2, 3);\n\t\n\tfunction sum(x: number, y: number): number &#123;\n    return x + y;\n\t&#125;\n\tsum(1);\n\n函数表达式如果要现在写一个对函数表达式的定义，可能会写成这样\nlet mySum = function (x: number, y: number): number &#123;\n   return x + y;\n&#125;;\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要手动给 mySum 添加类型，则应该是这样：\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number &#123;\n   return x + y;\n&#125;;\n注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。\n在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛\n用接口定义函数的形状也可以使用接口的方式来定义一个函数需要符合的形状：\ninterface SearchFunc &#123;\n   (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) &#123;\n   return source.search(subString) !== -1;\n&#125;\n可选参数输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n与接口中的可选属性类似，我们用 ? 表示可选的参数：\nfunction buildName(firstName: string, lastName?: string) &#123;\n   if (lastName) &#123;\n       return firstName + ' ' + lastName;\n   &#125; else &#123;\n       return firstName;\n   &#125;\n&#125;\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName('Tom');\n需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了\nfunction buildName(firstName?: string, lastName: string) &#123;\n   if (firstName) &#123;\n       return firstName + ' ' + lastName;\n   &#125; else &#123;\n       return lastName;\n   &#125;\n&#125;\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName(undefined, 'Tom');\n参数默认值在 ES6 中，允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：\n\tfunction buildName(firstName: string, lastName: string = 'Cat') &#123;\n    return firstName + ' ' + lastName;\n\t&#125;\n\tlet tomcat = buildName('Tom', 'Cat');\n\tlet tom = buildName('Tom');\n此时就不受「可选参数必须接在必需参数后面」的限制了：\n\n\tfunction buildName(firstName: string = 'Tom', lastName: string) &#123;\n    return firstName + ' ' + lastName;\n\t&#125;\n\tlet tomcat = buildName('Tom', 'Cat');\n\tlet cat = buildName(undefined, 'Cat');\n\n剩余参数ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）：\nfunction push(array, ...items) &#123;\n   items.forEach(function(item) &#123;\n       array.push(item);\n   &#125;);\n&#125;\n\nlet a = [];\npush(a, 1, 2, 3);\n\n事实上，items 是一个数组。所以可以用数组的类型来定义它：\nfunction push(array: any[], ...items: any[]) &#123;\n   items.forEach(function(item) &#123;\n       array.push(item);\n   &#125;);\n&#125;\n\nlet a = [];\npush(a, 1, 2, 3);\n注意，rest 参数只能是最后一个参数\n重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 &#39;hello&#39; 的时候，输出反转的字符串 &#39;olleh&#39;。\n利用联合类型，可以这么实现：\n\tfunction reverse(x: number | string): number | string &#123;\n   if (typeof x === 'number') &#123;\n       return Number(x.toString().split('').reverse().join(''));\n   &#125; else if (typeof x === 'string') &#123;\n       return x.split('').reverse().join('');\n   &#125;\n&#125;\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n这时，可以使用重载定义多个 reverse 的函数类型：\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string &#123;\n    if (typeof x === 'number') &#123;\n     \t\t return Number(x.toString().split('').reverse().join(''));\n    &#125; else if (typeof x === 'string') &#123;\n     \t\t return x.split('').reverse().join('');\n    &#125;\n&#125;\n上例中，重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n对象的类型——接口在 TypeScript 中，使用接口来定义对象的类型。\n在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状」进行描述。\n简单的例子interface Person &#123;\n   name: string;\nage: number;\n&#125;\n\nlet tom: Person = &#123;\nname: 'Tom',\nage: 25\n&#125;;\n定义了一个接口 Person，接着定义了一个变量 tom\n它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致\n接口一般首字母大写\n定义的变量比接口少了、多了一些一些属性是不允许的：\ninterface Person &#123;\n\tname: string;\n\tage: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: 'Tom'\n&#125;;\n\n// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '&#123; name: string; &#125;'.\n\n\tinterface Person &#123;\n    name: string;\n    age: number;\n\t&#125;\n\nlet tom: Person = &#123;\n\tname: 'Tom',\n   \tage: 25,\n\tgender: 'male'\n&#125;;\n\n// index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is \tnot assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type \t'Person'.\n可选属性有时希望不要完全匹配一个形状，那么可以用可选属性\ninterface Person &#123;\n\tname: string;\n   \tage?: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: 'Tom'\n&#125;;\n\nnterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: 'Tom',\n    age: 25\n&#125;;\n\n这时仍然不允许添加未定义的属性\ninterface Person &#123;\n   \tname: string;\n   \tage?: number;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   age: 25,\n   gender: 'male'\n&#125;;\n\n// examples/playground/index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; \tgender: string; &#125;' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type \t'Person'.\n任意属性有时候希望一个接口允许有任意的属性，可以使用如下方式：\ninterface Person &#123;\n   \tname: string;\n\tage?: number;\n   [propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   gender: 'male'\n&#125;;\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\ninterface Person &#123;\n   name: string;\n   age?: number;\n   [propName: string]: string;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   \tage: 25,\n   \tgender: 'male'\n&#125;;\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string \tindex type 'string'.\n// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: \tnumber; gender: string; &#125;' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n另外，在报错信息中可以看出，此时 &#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125; 的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合。\n只读属性有时候希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\ninterface Person &#123;\n   \treadonly id: number;\n   \tname: string;\n   \tage?: number;\n   \t[propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n   \tid: 89757,\n   \tname: 'Tom',\n   \tgender: 'male'\n&#125;;\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-\tonly property\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\ninterface Person &#123;\n   \treadonly id: number;\n   \tname: string;\n   \tage?: number;\n   \t[propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   gender: 'male'\n&#125;;\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable \tto type 'Person'.\n//   Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-\tonly property.\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。\n语法\n&lt;类型&gt;值\n    或\n值 as 类型\n\n在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种。\n例子：将一个联合类型的变量指定为一个更加具体的类型\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number &#123;\n   \treturn something.length;\n&#125;\n\n// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n而有时候，确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：\nfunction getLength(something: string | number): number &#123;\n   \tif (something.length) &#123;\n       \treturn something.length;\n   \t&#125; else &#123;\n       \treturn something.toString().length;\n   \t&#125;\n&#125;\n\n// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n// index.ts(3,26): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n上例中，获取 something.length 的时候会报错。\n此时可以使用类型断言，将 something 断言成 string4：\nfunction getLength(something: string | number): number &#123;\n   \tif ((&lt;string>something).length) &#123;\n       \treturn (&lt;string>something).length;\n   \t&#125; else &#123;\n       \treturn something.toString().length;\n   \t&#125;\n&#125;\n类型断言的用法如上，在需要断言的变量前加上 &lt;Type&gt; 即可。\n类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的：\nfunction toBoolean(something: string | number): boolean &#123;\n   \treturn &lt;boolean>something;\n&#125;\n\n// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.\n//   Type 'number' is not comparable to type 'boolean'.\n内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。\nECMAScript 的内置对象\nBoolean\nError\nDate\nRegExp\n……\n\n可以在 TypeScript 中将变量定义为这些类型：\nlet b: Boolean = new Boolean(1);\nlet e: Error = new Error('Error occurred');\nlet d: Date = new Date();\nlet r: RegExp = /[a-z]/;\n\nDOM 和 BOM 的内置对象\nDocument\nHTMLElement\nEvent\nNodeList\n……\n\nTypeScript 中会经常用到这些类型：\nlet body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll('div');\ndocument.addEventListener('click', function(e: MouseEvent) &#123;\n  // Do something\n&#125;);\nTypeScript 核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。\n当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：\nMath.pow(10, '2');\n\n// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter \tof type 'number'\n上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下：\ninterface Math &#123;\n\tpow(x: number, y: number): number;\n&#125;\nDOM 中的例子：\ndocument.addEventListener('click', function(e) &#123;\n   \tconsole.log(e.targetCurrent);\n&#125;);\n\n// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type \t'MouseEvent'.\n上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的：\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;\n\taddEventListener(type: string, listener: (ev: MouseEvent) => any, useCapture?: \tboolean): void;\n&#125;\n所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。\n注意，TypeScript 核心库的定义中不包含 Node.js 部分。\nNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：\nnpm install @types/node --save-dev\n\n未完待续…","slug":"TypeScript","date":"2022-03-27T13:02:26.000Z","categories_index":"","tags_index":"code","author_index":"Aurora"},{"id":"1269f6284fcda69dd94df081174c6509","title":"个人简历","content":"技术栈掌握\nHTML\nCSS\nJavaScript\nTypeScript\nES6\nVue3、Vue2\nVite\nwebpack\nNode.js\nReact\nESLint\nPrettier\nHusky\nCommitlint\nCommitizen\nCI\n小程序\ni18n\nMock\nGit\nEcharts\n\n了解\n跨平台 uni一类\nSSR\n设计模式\nWEB安全\nWEB性能\nHTTP\nNuxt\nWindiCSS\nEgg.js\nDocker\nnginx\nCanvas\nd3js\nthree.js\nWebGL\nRollup\n\n个人描述\n熟练掌握JavaScript，对于数据类型、作用域、闭包、异步、原型、事件循环、继承有一定了解\n\n熟练掌握Vue2、Vue3以及相关生态工具、UI组件库，包括但不限于Vue-Router、VueX、Vue-Cli、Vite、Pinia、Element UI、Vant……\n\n善于集成构建工具、校验工具、单元测试、集成测试、CI持续集成、Git、UI组件库、工具库、Vue、Vite相关插件减少代码量、约束编码风格、优化开发周期，从而整体提高开发效率以及代码质量和产品健壮性。\n\n热衷于对产品进行性能以及交互方面优化\n\n对新技术保持敏感持续关注技术动态以及相关博客\n\n坚持健身，有较强自律性以及身体素质\n\n\n工作经历阔孜纳克\n负责公司web项目（公众号、移动端、PC、小程序）需求评估、研发排期、任务分配、跟进\n与产品、UI同事完善产品交互流程、确定功能可行性；与服务端同事确定通信流程、设计接口\n根据项目类型（需求复杂度、迭代频率、研发周期）确定相关技术栈、GIT工作流\n维护、更新公司公共代码库（JSBridge、CLI、Hooks、常用方法、业务组件）\n定期组织web同事调研新技术、结合业务整合集成到现有技术架构中\n定期组织web同事Code Review、分享编码思想、互通业务、优化项目\n\n项目经历推广联盟 =&gt; 公众号、媒体控件相关为主\n项目介绍\n\n\n\n\n\n\n\n\n\n\n客户端分享影片资源以及信息至微信、QQ等相关社交平台，根据用户类型播放全片或试看；展示相关产品包。\n\n项目目的\n\n\n\n\n\n\n\n\n\n\n推广产品、增加用户数量，买会员、增加收益\n\n技术栈\n\n\n\n\n\n\n\n\n\n\nVue\n\n负责模块\n\n\n\n\n\n\n\n\n\n\n负责分享页鉴权播放、登陆、引导原始浏览器打开动画、唤起或下载客户端、微信公众号后台配置、与服务端制定接口\n\n取得成绩\n\n积分中心、农场、购买页 等客户端页面 app交互为主\n项目介绍\n\n\n\n\n\n\n\n\n\n\n积分中心与农场项目主要包括积分获取和积分商城，积分获取主要包括每日签到与积分任务，积分商城主要内容为限时会员为主的虚拟商品、实物，其中农场动画元素较多类似于蚂蚁农场。\n\n\n\n\n\n\n\n\n\n会员购买页主要为会员包的展示与购买，其中产品包包括自动续费与原价包。根据用户类型展示不同计费策略，与客户端约定支付流程，完成产品包的购买，整理平台接口。\n\n项目目的\n\n\n\n\n\n\n\n\n\n\n提高用户粘性、提高日活。\n\n技术栈\n\n\n\n\n\n\n\n\n\n\nVue\n\n负责模块\n\n\n\n\n\n\n\n\n\n\n登陆、用户类型判断、计费策略计算（根据用户类型组装产品以价格为主的基础信息）、支付、解约。与客户端制定相关交互、通信。\n\n取得成绩\n\n模板页 配置后台与前端为主\n项目介绍\n\n\n\n\n\n\n\n\n\n\n项目分为活动展示页、活动配置页。活动展示页包括产品包购买、影片、广告位、游戏位，根据配置页灵活配置渲染模板组件UI、布局、内容。\n\n项目目的\n\n\n\n\n\n\n\n\n\n\n尽可能满足日常活动的业务需求，灵活配置、灵活展示，以高复用率节省后续日常活动的开发成本。\n\n技术栈\n\n\n\n\n\n\n\n\n\n\nVue\n\n负责模块\n\n\n\n\n\n\n\n\n\n\n负责模板页开发、组件封装，主要包括产品包展示、产品包购买、观影、广告、游戏、登陆、与服务端共同设计接口、编写开发文档\n\n取得成绩\n活动页整合、优化\n项目介绍\n\n\n\n\n\n\n\n\n\n\n\n该项目为将以往活动项目进行整合并优化，主要整合方向为GIT仓库合并、Vue多页面模式、抽离公共代码块、抽离组件、采用hooks抽离耦合度较高的业务逻辑。\n\n项目目的\n\n\n\n\n\n\n\n\n\n\n解决了以往维护、迭代旧活动项目时Git仓库混乱，技术栈过旧、不统一的问题；多页面的项目关联有益于代码低耦合，高内聚，从而提高了新活动的开发周期。\n\n负责模块\n\n\n\n\n\n\n\n\n\n\n负责老项目的整理、脚手架的搭建、多页面配置、git分支建立、文档编写、抽离封装公共代码块、编写hooks\n商城 支付、埋点为主\n项目介绍\n\n\n\nkv平台 后台管理页面ott 优化为主创新项目 整合新技术栈、优化工作流、约束团队开发为主","slug":"about","date":"2022-03-25T10:12:48.000Z","categories_index":"","tags_index":"工作","author_index":"Aurora"}]