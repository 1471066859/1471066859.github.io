[{"id":"82f520d105a9d1713357ff985bd6be34","title":"Web历史与趋势","content":"","slug":"web-his","date":"2022-03-29T10:30:32.000Z","categories_index":"","tags_index":"工作,观点与感想","author_index":"马麒麟"},{"id":"79a0014fe93f3c37f36e94a135aef101","title":"软件工程的难点","content":"","slug":"engineered-software","date":"2022-03-29T10:30:15.000Z","categories_index":"","tags_index":"工作,观点与感想","author_index":"马麒麟"},{"id":"d24ff20ad1a722248c0f6ba78f471b7d","title":"前端工程化","content":"前端工程化什么是前端工程化前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间，而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。\n将系统化、规范化、可度量的方法用于前端应用的开发、运行和维护。\n用工程化的方法构建和维护有效的、实用的高质量前端应用。\n即开发 =&gt; 发布 =&gt; 运行 =&gt; 维护\n前端工程化的意义\n提高开发效率\n降低开发成本\n保证产品质量\n产品易扩展可维护\n\n工程化内容\n开发\n规范\n构建\n测试\n性能\n部署\n监控\n\n开发主要指对框架、组件库、工具库、开发模式、Mock、脚手架的选型和搭建\n规范在多人开发项目下，开发规范显得尤为重要，开发规范是产品规范主要包括以下几项\n\n编码规范\nAPI规范\nGit规范\n文档规范\n开发流程规范\n发布规范\n\n编码规范包括目录结构 、命名、风格、注释\n可借助校验工具强制约束，例如\n\nESlint\nPrettier\n\nAPI规范Git规范","slug":"engineered","date":"2022-03-29T10:26:40.000Z","categories_index":"","tags_index":"工作,观点与感想","author_index":"马麒麟"},{"id":"035e9fb91b64df4276e3d6de8a3ceb28","title":"applet","content":"小程序注册、迁移小程序注册（企业）填写主体信息并选择验证方式支付验证需要用公司的对公账户向腾讯公司打款来验证主体身份，打款信息在提交主体信息后可以查看到。请根据页面提示，向指定的收款帐号汇入指定金额。\n微信认证通过微信认证验证主体身份，需支付300元认证费。认证通过前，小程序部分功能暂无法使用\n小程序迁移流程注意事项迁移流程\n提交申请（广告主资金清零解绑、提交申请函、公证书、双方扫码认证）\n解除微信支付原主体商户号\n管理员确认迁移\n\n注意事项\n迁移目标主体不支持个人\n原主体不涉及资金相关功能流程会简化许多，如果支付功能尽可能先添加目标主体账户在做迁移。\n仅支持绑定原、目标主体的商户号的小程序迁移，若绑定了原、目标主体以外的商户号，暂不支持。在迁移流程中，若新增绑定了除原、目标主体以外的主体商户号，会导致迁移失败。\n需双方填写提交迁移材料并上传（重点）\n在迁移后，原有服务类目会失效，需重新填写提交审核（切拥有相关服务类目所需资质），如若成功迁移7天后线上代码与实际服务类目不符相关API权限将会失效并有小程序被下架风险。\n迁移如果选择修改小程序名，原小程序名会立即被释放无保护期。\n迁移过程用户无感\n开通的微信支付的企业，需要解绑原有商户号，绑定新主体商户号。开通了广告主的小程序，需要将账户余额清空。绑定了支付或广告服务商的小程序不支持主体迁移\n迁移费用300，无论成功与否\n\n","slug":"applet","date":"2022-03-29T05:27:51.000Z","categories_index":"","tags_index":"工作","author_index":"马麒麟"},{"id":"3cdc3782366cef9b905f84f886ca8afa","title":"JavaScript-初级","content":"JavaScript初级内置数据类型基本数据类型\nundefined\nNull\nBoolean\nString\nNumber\nSymbol（ES6）\nBigInt（ES6)\n\n基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n引用数据类型（Object）\nArray\nRegExp\nDate\nMath\nFunction\n\n种引用数据类型Object（Object本质上是由一组无序的名值对组成的）。里面包含 function、Array、Date等。JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。引用数据类型: 对象Object（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）\n引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n内存机制（JavaScript 中的数据是如何存储在内存中的）在 JavaScript 中，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间、堆空间。其中的代码空间主要是存储可执行代码的，原始类型(Number、String、Null、Undefined、Boolean、Symbol、BigInt)的数据值都是直接保存在“栈”中的，引用类型(Object)的值是存放在“堆”中的。因此在栈空间中(执行上下文)，原始类型存储的是变量的值，而引用类型存储的是其在”堆空间”中的地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。\n在编译过程中，如果 JavaScript 引擎判断到一个闭包，也会在堆空间创建换一个“**closure(fn)**”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存闭包中的变量。所以闭包中的变量是存储在“堆空间”中的。\nJavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。因此需要“栈”和“堆”两种空间。\n数据类型检测typeoftypeof 对于原始类型来说，除了 null 都可以显示正确的类型\n\nconsole.log(typeof 2);               // number\nconsole.log(typeof true);            // boolean\nconsole.log(typeof 'str');           // string\nconsole.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object\nconsole.log(typeof function()&#123;&#125;);    // function\nconsole.log(typeof &#123;&#125;);              // object\nconsole.log(typeof undefined);       // undefined\nconsole.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object\n\n\ntypeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型,所以想判断一个对象的正确类型，这时候可以考虑使用 instanceof\ninstanceofinstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 基本类型(null): 使用 String(null)基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断\nconsole.log(2 instanceof Number);                    // false\nconsole.log(true instanceof Boolean);                // false \nconsole.log('str' instanceof String);                // false  \nconsole.log([] instanceof Array);                    // true\nconsole.log(function()&#123;&#125; instanceof Function);       // true\nconsole.log(&#123;&#125; instanceof Object);                   // true    \n// console.log(undefined instanceof Undefined);\n// console.log(null instanceof Null);\n\n\n\ninstanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型；\n而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断\n\n\n// 我们也可以试着实现一下 instanceof\nfunction instanceof(left, right) &#123;\n// 获得类型的原型\nlet prototype = right.prototype\n// 获得对象的原型\nleft = left.__proto__\n// 判断对象的类型是否等于类型的原型\nwhile (true) &#123;\nif (left === null)\nreturn false\nif (prototype === left)\nreturn true\nleft = left.__proto__\n&#125;\n&#125;\n\n\nconstructorconsole.log((2).constructor === Number); // true\nconsole.log((true).constructor === Boolean); // true\nconsole.log(('str').constructor === String); // true\nconsole.log(([]).constructor === Array); // true\nconsole.log((function() &#123;&#125;).constructor === Function); // true\nconsole.log((&#123;&#125;).constructor === Object); // true\n\n\n这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了\nfunction Fn()&#123;&#125;;\n\nFn.prototype=new Array();\n \nvar f=new Fn();\n \nconsole.log(f.constructor===Fn);    // false\nconsole.log(f.constructor===Array); // true \n\nObject.prototype.toString.call() toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “**[object Xxx]**” 的字符串，其中 Xxx 就是对象的类型。对于 Object 对象，直接调用 toString() 就能返回 **[object Object]**；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息。我们来看一下代码。\nObject.prototype.toString(&#123;&#125;)       // \"[object Object]\"\nObject.prototype.toString.call(&#123;&#125;)  // 同上结果，加上call也ok\nObject.prototype.toString.call(1)    // \"[object Number]\"\nObject.prototype.toString.call('1')  // \"[object String]\"\nObject.prototype.toString.call(true)  // \"[object Boolean]\"\nObject.prototype.toString.call(function()&#123;&#125;)  // \"[object Function]\"\nObject.prototype.toString.call(null)   //\"[object Null]\"\nObject.prototype.toString.call(undefined) //\"[object Undefined]\"\nObject.prototype.toString.call(/123/g)    //\"[object RegExp]\"\nObject.prototype.toString.call(new Date()) //\"[object Date]\"\nObject.prototype.toString.call([])       //\"[object Array]\"\nObject.prototype.toString.call(document)  //\"[object HTMLDocument]\"\nObject.prototype.toString.call(window)   //\"[object Window]\"\n\n// 从上面这段代码可以看出，Object.prototype.toString.call() 可以很好地判断引用类型，甚至可以把 document 和 window 都区分开来。\n\n实现一个全局通用的数据类型判断方法，来加深你的理解，代码如下\n\nfunction getType(obj)&#123;\n  let type  = typeof obj;\n  if (type !== \"object\") &#123;    // 先进行typeof判断，如果是基础数据类型，直接返回\n    return type;\n  &#125;\n  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果\n  return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1');  // 注意正则中间\t有个空格\n&#125;\n/* 代码验证，需要注意大小写，哪些是typeof判断，哪些是toString判断？思考下 */\ngetType([])     // \"Array\" typeof []是object，因此toString返回\ngetType('123')  // \"string\" typeof 直接返回\ngetType(window) // \"Window\" toString返回\ngetType(null)   // \"Null\"首字母大写，typeof null是object，需toString来判断\ngetType(undefined)   // \"undefined\" typeof 直接返回\ngetType()            // \"undefined\" typeof 直接返回\ngetType(function()&#123;&#125;) // \"function\" typeof能判断，因此首字母小写\ngetType(/123/g)      //\"RegExp\" toString返回\n\n小结\ntypeof\n直接在计算机底层基于数据类型的值（二进制）进行检测\ntypeof null为object 原因是对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象\ntypeof 普通对象/数组对象/正则对象/日期对象 都是object\ntypeof NaN === ‘number’\n\n\ninstanceof\n检测当前实例是否属于这个类的\n底层机制：只要当前类出现在实例的原型上，结果都是true\n不能检测基本数据类型\n\n\nconstructor\n支持基本类型\nconstructor可以随便改，也不准\n\n\nObject.prototype.toString.call([val])\n返回当前实例所属类信息\n\n\n\n 判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:\n\n基本类型(null): 使用 String(null)\n基本类型(string / number / boolean / undefined) + function: - 直接使用 typeof即可\n其余引用类型(Array / Date / RegExp Error): 调用toString后根据**[object XXX]**进行判断\n\n","slug":"JavaScript-primary","date":"2022-03-29T05:05:22.000Z","categories_index":"","tags_index":"code","author_index":"马麒麟"},{"id":"5e2ed994fcc6085bef4fc36a901c80bc","title":"JavaScript-高级","content":"JS高级this面向对象语言中this表示当前对象的一个引用。\n但在JavaScript中this不是固定不变的，它会随着执行环境的改变而改变。\n在方法中，this表示该方法所属的对象var obj = &#123;\n\tfirstName: \"Ma\",\n\tlastName: \"QiLin\",\n\tgetNameFn: function() &#123;\n\t\treturn this. firstName + this.lastName\n\t\t&#125;\n\t&#125;;\n\n\n在对象方法中，this指向调用它所在方法的对象。\n在上面一个实例中，this表示obj对象。\nfullName方法所属的对象就是obj。\n\n如果单独使用this表示全局对象var x = this;\n\n\n\n单独使用this，则它指向全局Global对象。\n在浏览器中，window 就是该全局对象为 [object Window]:\n严格模式下，如果单独使用，this 也是指向全局Global对象。\n\n在函数中，this表示全局对象，严格模式下为undefinedfunction fn() &#123;\n\treturn this;\n&#125;;\n\n\n在函数中，函数的所属者默认绑定到 this 上。\n在浏览器中，window 就是该全局对象为 [object Window]:\n严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。\n\n在事件中，this表示接收事件的元素&lt;button onclick=\"this.style.display='none'\">\n\t点我后我就消失了\n&lt;/button>\n\n\n在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：\n\n类似 call() 和 apply() 方法可以将 this 引用到任何对象（更改this指向）var person1 = &#123;\n\tfullName: function() &#123;\n\t\treturn this.firstName + \" \" + this.lastName;\n\t&#125;\n&#125;\nvar person2 = &#123;\n\tfirstName:\"John\",\n\tlastName: \"Doe\",\n&#125;\nperson1.fullName.call(person2);  // 返回 \"John Doe\"\n\n\n在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境context，即 this 绑定的对象。\n\n在上面面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法：\n\n\n在构造函数中this表示实例function fn (name, age) &#123;\n\tthis.name = name;\n\tthis.age = age;\n&#125;;\n\t\nconst f1 = new fn('mql', 18);\nconsole.log(f1); // &#123; name: 'mql', age: 18 &#125;\n\n\n闭包原型、原型链JS在设计时并没有采用其他语言的class概念，而采用的时原型继承的设计模式。可以粗略理解问，原型 + 构造函数 + 原型链 形成的继承模式为 JAVA中的类class模式\n构造函数什么是构造函数在 JavaScript 中，用 new 关键字来调用的函数，称为构造函数。\nfunction fn() &#123;\n\tname: 'card',\n&#125;;\n\t\t\nconst f1 = new fn(); // &#123; name: 'card' &#125;;\n\n为什么实用构造函数比如：现有一个造车工厂，每个车都有一些配置参数，代码如下\ncard1 = &#123;\n\tcolor: \"红色\",\n\tname: '奔驰',\n\tprice: '40w'\n&#125;;\n\t\t\ncard2 = &#123;\n\tcolor: '白色',\n\tname: '奔驰',\n\tprice: '60w'\n&#125;;\n....\n\n\n从数据中可以看出，每辆车有很多属性，有相同的，有独立不同的。如果汽车多了，我们就会写很多类似的代码。构造函数工厂模式就是解决这一难题。代码如下\nfunction card(color, price) &#123;\n\tthis.name = '奔驰';\n\tthis.color = color;\n\tthis.price = price;\n&#125;;\n\t\t\nconst card1 = new card( '红色', 400000 );\n// &#123; color: '红色', name: '奔驰', price: '4000000' &#125;\nconst card2 = new card('白色', 6000000);\n\n构造函数执行过程及原理\n当card1用new关键字调用card方法时，会为card1开辟一个新内存，且card中的this指向该内存即card1.代码如下\n\nconst card1 = new card('白色', 6000000); \n// 开辟一个新的内存空间card1 并且card的this指向该空间\n\n构造函数返回值由于函数体内部的 this 指向新创建的内存空间，默认返回 this ，就相当于默认返回了该内存空间，也就是上图中的 card1。此时，card1的内存空间被变量 card1 所接受。也就是说 card1 这个变量，保存的内存地址就是 card1，同时被标记为 card 的实例。\n缺点实例在调用构造函数时会开辟一个新的内存空间，前面提到过公共属性，例如name属性。如此便在内存空间都会有name属性，这无疑是很浪费内存的。这种情况可以采用原型+原型链的方法共享属性。无需单独创建。代码如下\n\nfunction card(color, price) &#123;\n\tthis.color = color;\n\tthis.price = pirce;\n&#125;;\n// 通过在原型上添加公共属性`name` 让实例继承\ncard. prototype.name = '奔驰';\nconst card1 = new card('红色', 400000) // &#123; color:'红色', price: 40000, name: '奔驰' &#125;\t\t\n\n\n\n\n数据类型 =&gt; 栈、堆回调函数异步执行机制、事件循环、事件队列单线程JavaScript是单线程语言、\n","slug":"JavaScript-senior","date":"2022-03-29T04:47:23.000Z","categories_index":"","tags_index":"code","author_index":"马麒麟"},{"id":"0aaa27c48e7b40c2bc96b31fb70803da","title":"TypeScript","content":"TypeScriptTypeScript是由微软推出并推动的一个静态类型检查的编译型编程语言，可以完美兼容ES6的JavaScript。目前大量前端库和应用使用TS开发，已然成为前端的主流开发语言。\n优势\n静态编译，减少JS动态语言特性带来了的非常多的隐藏bug\n类型安全检查在编译阶段完成\n大型项目的更好的进行管理和向后约定维护\n为前端的彻底的静态安全的类型检查、类型继承、抽象设计体系铺好了基石\n更加友好的智能提示和文档说明\n\n安装TypeScript有两种主要的方式来获取TypeScript工具\n\n通过npm安装\n  npm install -g typescript\n\n安装Visual Studio的TypeScript插件\n\n\n编译代码启动编译后，可以添加-w参数，让编译工具一直监听文件的变化，ts文件变化后自动编译。\ntsc -w tyDemon.ts\n    or\ntsc --watch tyDemon.ts\n\n编译多个ts文件\n\n编译当前目录下的所有的ts文件\n  tsc -w *.ts\n\n\n编译当前目录及子目录的ts文件\n  tsc -w ./**/*.ts\n\n\n\n数据类型布尔值最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean\nlet isDone: boolean = false; \n// 冒号后面是对当前变量类型的声明，isDone只能赋值布尔类型值，否则会编译失败。\n\n数字和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ES5中引入的二进制和八进制字面量\nlet num1: number = 6;\nlet num2: number = 0xf00d;\nlet num3: number = 0b1010;\nlet num4: number = 0o744;\n\n字符串JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号&quot;或单引号&#39;表示字符串\nlet name: string = \"bob\";\nname = \"smith\";\n\n数组TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组\nlet list: number[] = [1, 2, 3];\nlet list: Array&lt;number> = [1, 2, 3];\n元祖元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\nlet x: [string, number];\nx = ['hello', 10]; // OK\nx = [10, 'hello']; // Error\n\nany有时候，会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量\nlet any1: any = 4;\nany1 = \"maybe a string instead\";\nany2 = false; \n\nvoid它表示没有任何类型。 当一个函数没有返回值时，会见到其返回值类型是void\nfunction fn(): void &#123;\n   console.log(\"This is message\");\n&#125;\n\n声明void变量只能给其赋值为null, undefined\nlet void1: void = undefined;\n\nNull 和 Undefinedundefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似。\nlet u: undefined = undefined;\nlet n: null = null;\n\nObjectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。\ndeclare function create(o: object | null): void;\n\ncreate(&#123; prop: 0 &#125;); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n\n枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予名字。\nenum Color &#123;Red, Green, Blue&#125;\nlet c: Color = Color.Green;\n默认情况下，从0开始为元素编号。 也可以手动的指定成员的数值。 例如，将上面的例子改成从 1开始编号：\nenum Color &#123;Red = 1, Green, Blue&#125;\nlet c: Color = Color.Green;\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，可以查找相应的名字\nenum Color &#123;Red = 1, Green, Blue&#125;\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示'Green'因为上面代码里它的值是2\n函数函数的声明 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单\n \tfunction sum(x: number, y: number): number &#123;\n    return x + y;\n\t&#125;\n输入多余的（或者少于要求的）参数，是不被允许的\n\n\tfunction sum(x: number, y: number): number &#123;\n    return x + y;\n\t&#125;\n\tsum(1, 2, 3);\n\t\n\tfunction sum(x: number, y: number): number &#123;\n    return x + y;\n\t&#125;\n\tsum(1);\n\n函数表达式如果要现在写一个对函数表达式的定义，可能会写成这样\nlet mySum = function (x: number, y: number): number &#123;\n   return x + y;\n&#125;;\n这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要手动给 mySum 添加类型，则应该是这样：\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number &#123;\n   return x + y;\n&#125;;\n注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。\n在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛\n用接口定义函数的形状也可以使用接口的方式来定义一个函数需要符合的形状：\ninterface SearchFunc &#123;\n   (source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) &#123;\n   return source.search(subString) !== -1;\n&#125;\n可选参数输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n与接口中的可选属性类似，我们用 ? 表示可选的参数：\nfunction buildName(firstName: string, lastName?: string) &#123;\n   if (lastName) &#123;\n       return firstName + ' ' + lastName;\n   &#125; else &#123;\n       return firstName;\n   &#125;\n&#125;\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName('Tom');\n需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了\nfunction buildName(firstName?: string, lastName: string) &#123;\n   if (firstName) &#123;\n       return firstName + ' ' + lastName;\n   &#125; else &#123;\n       return lastName;\n   &#125;\n&#125;\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName(undefined, 'Tom');\n参数默认值在 ES6 中，允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：\n\tfunction buildName(firstName: string, lastName: string = 'Cat') &#123;\n    return firstName + ' ' + lastName;\n\t&#125;\n\tlet tomcat = buildName('Tom', 'Cat');\n\tlet tom = buildName('Tom');\n此时就不受「可选参数必须接在必需参数后面」的限制了：\n\n\tfunction buildName(firstName: string = 'Tom', lastName: string) &#123;\n    return firstName + ' ' + lastName;\n\t&#125;\n\tlet tomcat = buildName('Tom', 'Cat');\n\tlet cat = buildName(undefined, 'Cat');\n\n剩余参数ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）：\nfunction push(array, ...items) &#123;\n   items.forEach(function(item) &#123;\n       array.push(item);\n   &#125;);\n&#125;\n\nlet a = [];\npush(a, 1, 2, 3);\n\n事实上，items 是一个数组。所以可以用数组的类型来定义它：\nfunction push(array: any[], ...items: any[]) &#123;\n   items.forEach(function(item) &#123;\n       array.push(item);\n   &#125;);\n&#125;\n\nlet a = [];\npush(a, 1, 2, 3);\n注意，rest 参数只能是最后一个参数\n重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 &#39;hello&#39; 的时候，输出反转的字符串 &#39;olleh&#39;。\n利用联合类型，可以这么实现：\n\tfunction reverse(x: number | string): number | string &#123;\n   if (typeof x === 'number') &#123;\n       return Number(x.toString().split('').reverse().join(''));\n   &#125; else if (typeof x === 'string') &#123;\n       return x.split('').reverse().join('');\n   &#125;\n&#125;\n然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n这时，可以使用重载定义多个 reverse 的函数类型：\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string &#123;\n    if (typeof x === 'number') &#123;\n     \t\t return Number(x.toString().split('').reverse().join(''));\n    &#125; else if (typeof x === 'string') &#123;\n     \t\t return x.split('').reverse().join('');\n    &#125;\n&#125;\n上例中，重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n对象的类型——接口在 TypeScript 中，使用接口来定义对象的类型。\n在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状」进行描述。\n简单的例子interface Person &#123;\n   name: string;\nage: number;\n&#125;\n\nlet tom: Person = &#123;\nname: 'Tom',\nage: 25\n&#125;;\n定义了一个接口 Person，接着定义了一个变量 tom\n它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致\n接口一般首字母大写\n定义的变量比接口少了、多了一些一些属性是不允许的：\ninterface Person &#123;\n\tname: string;\n\tage: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: 'Tom'\n&#125;;\n\n// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.\n//   Property 'age' is missing in type '&#123; name: string; &#125;'.\n\n\tinterface Person &#123;\n    name: string;\n    age: number;\n\t&#125;\n\nlet tom: Person = &#123;\n\tname: 'Tom',\n   \tage: 25,\n\tgender: 'male'\n&#125;;\n\n// index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is \tnot assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type \t'Person'.\n可选属性有时希望不要完全匹配一个形状，那么可以用可选属性\ninterface Person &#123;\n\tname: string;\n   \tage?: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: 'Tom'\n&#125;;\n\nnterface Person &#123;\n    name: string;\n    age?: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: 'Tom',\n    age: 25\n&#125;;\n\n这时仍然不允许添加未定义的属性\ninterface Person &#123;\n   \tname: string;\n   \tage?: number;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   age: 25,\n   gender: 'male'\n&#125;;\n\n// examples/playground/index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; \tgender: string; &#125;' is not assignable to type 'Person'.\n//   Object literal may only specify known properties, and 'gender' does not exist in type \t'Person'.\n任意属性有时候希望一个接口允许有任意的属性，可以使用如下方式：\ninterface Person &#123;\n   \tname: string;\n\tage?: number;\n   [propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   gender: 'male'\n&#125;;\n\n使用 [propName: string] 定义了任意属性取 string 类型的值。\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：\ninterface Person &#123;\n   name: string;\n   age?: number;\n   [propName: string]: string;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   \tage: 25,\n   \tgender: 'male'\n&#125;;\n\n// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string \tindex type 'string'.\n// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: \tnumber; gender: string; &#125;' is not assignable to type 'Person'.\n//   Index signatures are incompatible.\n//     Type 'string | number' is not assignable to type 'string'.\n//       Type 'number' is not assignable to type 'string'.\n\n上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。\n另外，在报错信息中可以看出，此时 &#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125; 的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合。\n只读属性有时候希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：\ninterface Person &#123;\n   \treadonly id: number;\n   \tname: string;\n   \tage?: number;\n   \t[propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n   \tid: 89757,\n   \tname: 'Tom',\n   \tgender: 'male'\n&#125;;\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-\tonly property\n上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\ninterface Person &#123;\n   \treadonly id: number;\n   \tname: string;\n   \tage?: number;\n   \t[propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n   \tname: 'Tom',\n   gender: 'male'\n&#125;;\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable \tto type 'Person'.\n//   Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.\n// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-\tonly property.\n\n上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。\n类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。\n语法\n&lt;类型&gt;值\n    或\n值 as 类型\n\n在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种。\n例子：将一个联合类型的变量指定为一个更加具体的类型\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number &#123;\n   \treturn something.length;\n&#125;\n\n// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n而有时候，确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：\nfunction getLength(something: string | number): number &#123;\n   \tif (something.length) &#123;\n       \treturn something.length;\n   \t&#125; else &#123;\n       \treturn something.toString().length;\n   \t&#125;\n&#125;\n\n// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n// index.ts(3,26): error TS2339: Property 'length' does not exist on type 'string | number'.\n//   Property 'length' does not exist on type 'number'.\n上例中，获取 something.length 的时候会报错。\n此时可以使用类型断言，将 something 断言成 string4：\nfunction getLength(something: string | number): number &#123;\n   \tif ((&lt;string>something).length) &#123;\n       \treturn (&lt;string>something).length;\n   \t&#125; else &#123;\n       \treturn something.toString().length;\n   \t&#125;\n&#125;\n类型断言的用法如上，在需要断言的变量前加上 &lt;Type&gt; 即可。\n类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的：\nfunction toBoolean(something: string | number): boolean &#123;\n   \treturn &lt;boolean>something;\n&#125;\n\n// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.\n//   Type 'number' is not comparable to type 'boolean'.\n内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。\nECMAScript 的内置对象\nBoolean\nError\nDate\nRegExp\n……\n\n可以在 TypeScript 中将变量定义为这些类型：\nlet b: Boolean = new Boolean(1);\nlet e: Error = new Error('Error occurred');\nlet d: Date = new Date();\nlet r: RegExp = /[a-z]/;\n\nDOM 和 BOM 的内置对象\nDocument\nHTMLElement\nEvent\nNodeList\n……\n\nTypeScript 中会经常用到这些类型：\nlet body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll('div');\ndocument.addEventListener('click', function(e: MouseEvent) &#123;\n  // Do something\n&#125;);\nTypeScript 核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。\n当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：\nMath.pow(10, '2');\n\n// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter \tof type 'number'\n上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下：\ninterface Math &#123;\n\tpow(x: number, y: number): number;\n&#125;\nDOM 中的例子：\ndocument.addEventListener('click', function(e) &#123;\n   \tconsole.log(e.targetCurrent);\n&#125;);\n\n// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type \t'MouseEvent'.\n上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的：\ninterface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;\n\taddEventListener(type: string, listener: (ev: MouseEvent) => any, useCapture?: \tboolean): void;\n&#125;\n所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。\n注意，TypeScript 核心库的定义中不包含 Node.js 部分。\nNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：\nnpm install @types/node --save-dev\n\n未完待续…","slug":"TypeScript","date":"2022-03-27T13:02:26.000Z","categories_index":"","tags_index":"code","author_index":"马麒麟"}]