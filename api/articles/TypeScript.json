{"title":"TypeScript","uid":"0aaa27c48e7b40c2bc96b31fb70803da","slug":"TypeScript","date":"2022-03-27T13:02:26.000Z","updated":"2022-03-27T14:15:57.372Z","comments":true,"path":"api/articles/TypeScript.json","keywords":null,"cover":null,"content":"<h1 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h1><p><code>TypeScript</code>是由微软推出并推动的一个静态类型检查的编译型编程语言，可以完美兼容ES6的<code>JavaScript</code>。目前大量前端库和应用使用<code>TS</code>开发，已然成为前端的主流开发语言。</p>\n<h2 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h2><ul>\n<li>静态编译，减少<code>JS</code>动态语言特性带来了的非常多的隐藏bug</li>\n<li>类型安全检查在编译阶段完成</li>\n<li>大型项目的更好的进行管理和向后约定维护</li>\n<li>为前端的彻底的静态安全的类型检查、类型继承、抽象设计体系铺好了基石</li>\n<li>更加友好的智能提示和文档说明</li>\n</ul>\n<h2 id=\"安装TypeScript\"><a href=\"#安装TypeScript\" class=\"headerlink\" title=\"安装TypeScript\"></a>安装TypeScript</h2><p>有两种主要的方式来获取<code>TypeScript</code>工具</p>\n<ul>\n<li><p>通过<code>npm</code>安装</p>\n<p>  <code>npm install -g typescript</code></p>\n</li>\n<li><p>安装Visual Studio的<code>TypeScript</code>插件</p>\n</li>\n</ul>\n<h2 id=\"编译代码\"><a href=\"#编译代码\" class=\"headerlink\" title=\"编译代码\"></a>编译代码</h2><p>启动编译后，可以添加<code>-w</code>参数，让编译工具一直监听文件的变化，<code>ts</code>文件变化后自动编译。</p>\n<pre><code>tsc -w tyDemon.ts\n    or\ntsc --watch tyDemon.ts\n</code></pre>\n<p>编译多个<code>ts</code>文件</p>\n<ul>\n<li><p>编译当前目录下的所有的<code>ts</code>文件</p>\n<pre><code>  tsc -w *.ts\n</code></pre>\n</li>\n<li><p>编译当前目录及子目录的<code>ts</code>文件</p>\n<pre><code>  tsc -w ./**/*.ts\n</code></pre>\n</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>最基本的数据类型就是简单的<code>true</code>/<code>false</code>值，在<code>JavaScript</code>和<code>TypeScript</code>里叫做<code>boolean</code></p>\n<pre><code>let isDone: boolean = false; \n// 冒号后面是对当前变量类型的声明，isDone只能赋值布尔类型值，否则会编译失败。\n</code></pre>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>和<code>JavaScript</code>一样，<code>TypeScript</code>里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，<code>TypeScript</code>还支持<code>ES5</code>中引入的二进制和八进制字面量</p>\n<pre><code>let num1: number = 6;\nlet num2: number = 0xf00d;\nlet num3: number = 0b1010;\nlet num4: number = 0o744;\n</code></pre>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p><code>JavaScript</code>程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code>表示文本数据类型。 和<code>JavaScript</code>一样，可以使用双引号<code>&quot;</code>或单引号<code>&#39;</code>表示字符串</p>\n<pre><code>let name: string = &quot;bob&quot;;\nname = &quot;smith&quot;;\n</code></pre>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p><code>TypeScript</code>像<code>JavaScript</code>一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组</p>\n<pre><code>let list: number[] = [1, 2, 3];\nlet list: Array&lt;number&gt; = [1, 2, 3];\n</code></pre>\n<h3 id=\"元祖\"><a href=\"#元祖\" class=\"headerlink\" title=\"元祖\"></a>元祖</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p>\n<pre><code>let x: [string, number];\nx = [&#39;hello&#39;, 10]; // OK\nx = [10, &#39;hello&#39;]; // Error\n</code></pre>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><p>有时候，会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量</p>\n<pre><code>let any1: any = 4;\nany1 = &quot;maybe a string instead&quot;;\nany2 = false; \n</code></pre>\n<h3 id=\"void\"><a href=\"#void\" class=\"headerlink\" title=\"void\"></a>void</h3><p>它表示没有任何类型。 当一个函数没有返回值时，会见到其返回值类型是<code>void</code></p>\n<pre><code>function fn(): void &#123;\nconsole.log(&quot;This is message&quot;);\n&#125;\n</code></pre>\n<p>声明<code>void</code>变量只能给其赋值为<code>null</code>, <code>undefined</code></p>\n<pre><code>let void1: void = undefined;\n</code></pre>\n<h3 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h3><p><code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。 和 <code>void</code>相似。</p>\n<pre><code>let u: undefined = undefined;\nlet n: null = null;\n</code></pre>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>\n<pre><code>declare function create(o: object | null): void;\n\ncreate(&#123; prop: 0 &#125;); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(&quot;string&quot;); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n</code></pre>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p><code>enum</code>类型是对<code>JavaScript</code>标准数据类型的一个补充。 像<code>C#</code>等其它语言一样，使用枚举类型可以为一组数值赋予名字。</p>\n<pre><code>enum Color &#123;Red, Green, Blue&#125;\nlet c: Color = Color.Green;\n</code></pre>\n<p>默认情况下，从0开始为元素编号。 也可以手动的指定成员的数值。 例如，将上面的例子改成从 1开始编号：</p>\n<pre><code>enum Color &#123;Red = 1, Green, Blue&#125;\nlet c: Color = Color.Green;\n</code></pre>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到<code>Color</code>里的哪个名字，可以查找相应的名字</p>\n<pre><code>enum Color &#123;Red = 1, Green, Blue&#125;\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示&#39;Green&#39;因为上面代码里它的值是2\n</code></pre>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h4><p> 一个函数有输入和输出，要在 <code>TypeScript</code> 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单</p>\n<pre><code>function sum(x: number, y: number): number &#123;\nreturn x + y;\n&#125;\n</code></pre>\n<p>输入多余的（或者少于要求的）参数，是不被允许的</p>\n<pre><code>function sum(x: number, y: number): number &#123;\nreturn x + y;\n&#125;\nsum(1, 2, 3);\n\nfunction sum(x: number, y: number): number &#123;\nreturn x + y;\n&#125;\nsum(1);\n</code></pre>\n<h4 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h4><p>如果要现在写一个对函数表达式的定义，可能会写成这样</p>\n<pre><code>let mySum = function (x: number, y: number): number &#123;\nreturn x + y;\n&#125;;\n</code></pre>\n<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要手动给 <code>mySum</code> 添加类型，则应该是这样：</p>\n<pre><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;\nreturn x + y;\n&#125;;\n</code></pre>\n<p>注意不要混淆了 <code>TypeScript</code> 中的 <code>=&gt;</code> 和 <code>ES6</code> 中的 <code>=&gt;</code>。</p>\n<p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>\n<p>在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛</p>\n<h4 id=\"用接口定义函数的形状\"><a href=\"#用接口定义函数的形状\" class=\"headerlink\" title=\"用接口定义函数的形状\"></a>用接口定义函数的形状</h4><p>也可以使用接口的方式来定义一个函数需要符合的形状：</p>\n<pre><code>interface SearchFunc &#123;\n(source: string, subString: string): boolean;\n&#125;\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) &#123;\nreturn source.search(subString) !== -1;\n&#125;\n</code></pre>\n<h4 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h4><p>输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>\n<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>\n<pre><code>function buildName(firstName: string, lastName?: string) &#123;\nif (lastName) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125; else &#123;\n    return firstName;\n&#125;\n&#125;\nlet tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);\nlet tom = buildName(&#39;Tom&#39;);\n</code></pre>\n<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了</p>\n<pre><code>function buildName(firstName?: string, lastName: string) &#123;\nif (firstName) &#123;\n    return firstName + &#39; &#39; + lastName;\n&#125; else &#123;\n    return lastName;\n&#125;\n&#125;\nlet tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);\nlet tom = buildName(undefined, &#39;Tom&#39;);\n</code></pre>\n<h4 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h4><p>在 ES6 中，允许给函数的参数添加默认值，<code>TypeScript</code> 会将添加了默认值的参数识别为可选参数：</p>\n<pre><code>function buildName(firstName: string, lastName: string = &#39;Cat&#39;) &#123;\nreturn firstName + &#39; &#39; + lastName;\n&#125;\nlet tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);\nlet tom = buildName(&#39;Tom&#39;);\n</code></pre>\n<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>\n<pre><code>function buildName(firstName: string = &#39;Tom&#39;, lastName: string) &#123;\nreturn firstName + &#39; &#39; + lastName;\n&#125;\nlet tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);\nlet cat = buildName(undefined, &#39;Cat&#39;);\n</code></pre>\n<h4 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h4><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>\n<pre><code>function push(array, ...items) &#123;\nitems.forEach(function(item) &#123;\n    array.push(item);\n&#125;);\n&#125;\n\nlet a = [];\npush(a, 1, 2, 3);\n</code></pre>\n<p>事实上，<code>items</code> 是一个数组。所以可以用数组的类型来定义它：</p>\n<pre><code>function push(array: any[], ...items: any[]) &#123;\nitems.forEach(function(item) &#123;\n    array.push(item);\n&#125;);\n&#125;\n\nlet a = [];\npush(a, 1, 2, 3);\n</code></pre>\n<p>注意，rest 参数只能是最后一个参数</p>\n<h4 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h4><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>\n<p>比如，需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p>\n<p>利用联合类型，可以这么实现：</p>\n<pre><code>    function reverse(x: number | string): number | string &#123;\nif (typeof x === &#39;number&#39;) &#123;\n    return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n&#125; else if (typeof x === &#39;string&#39;) &#123;\n    return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n&#125;\n&#125;\n</code></pre>\n<p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</p>\n<p>这时，可以使用重载定义多个 <code>reverse</code> 的函数类型：</p>\n<pre><code>    function reverse(x: number): number;\n    function reverse(x: string): string;\n    function reverse(x: number | string): number | string &#123;\n        if (typeof x === &#39;number&#39;) &#123;\n            return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));\n        &#125; else if (typeof x === &#39;string&#39;) &#123;\n            return x.split(&#39;&#39;).reverse().join(&#39;&#39;);\n        &#125;\n    &#125;\n</code></pre>\n<p>上例中，重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>\n<p>注意，<code>TypeScript</code> 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>\n<h2 id=\"对象的类型——接口\"><a href=\"#对象的类型——接口\" class=\"headerlink\" title=\"对象的类型——接口\"></a>对象的类型——接口</h2><p>在 <code>TypeScript</code> 中，使用接口来定义对象的类型。</p>\n<p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p>\n<p><code>TypeScript</code> 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状」进行描述。</p>\n<h3 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h3><pre><code>    interface Person &#123;\n    name: string;\n    age: number;\n    &#125;\n\n    let tom: Person = &#123;\n    name: &#39;Tom&#39;,\n    age: 25\n    &#125;;\n    \n    定义了一个接口 Person，接着定义了一个变量 tom\n    它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致\n    接口一般首字母大写\n</code></pre>\n<p>定义的变量比接口少了、多了一些一些属性是不允许的：</p>\n<pre><code>interface Person &#123;\n    name: string;\n    age: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: &#39;Tom&#39;\n&#125;;\n\n// index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n//   Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.\n\n    interface Person &#123;\n    name: string;\n    age: number;\n    &#125;\n\nlet tom: Person = &#123;\n    name: &#39;Tom&#39;,\n       age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n// index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is     not assignable to type &#39;Person&#39;.\n//   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type     &#39;Person&#39;.\n</code></pre>\n<h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h3><p>有时希望不要完全匹配一个形状，那么可以用可选属性</p>\n<pre><code>    interface Person &#123;\n        name: string;\n           age?: number;\n    &#125;\n\n    let tom: Person = &#123;\n        name: &#39;Tom&#39;\n    &#125;;\n    \n    nterface Person &#123;\n        name: string;\n        age?: number;\n    &#125;\n\n    let tom: Person = &#123;\n        name: &#39;Tom&#39;,\n        age: 25\n    &#125;;\n</code></pre>\n<p>这时仍然不允许添加未定义的属性</p>\n<pre><code>interface Person &#123;\n    name: string;\n       age?: number;\n&#125;\n\nlet tom: Person = &#123;\n    name: &#39;Tom&#39;,\n   age: 25,\n   gender: &#39;male&#39;\n&#125;;\n\n// examples/playground/index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number;     gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n//   Object literal may only specify known properties, and &#39;gender&#39; does not exist in type     &#39;Person&#39;.\n</code></pre>\n<h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h3><p>有时候希望一个接口允许有任意的属性，可以使用如下方式：</p>\n<pre><code>interface Person &#123;\n       name: string;\n    age?: number;\n   [propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n    name: &#39;Tom&#39;,\n   gender: &#39;male&#39;\n&#125;;\n</code></pre>\n<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>\n<p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p>\n<pre><code>interface Person &#123;\nname: string;\nage?: number;\n[propName: string]: string;\n&#125;\n\nlet tom: Person = &#123;\n    name: &#39;Tom&#39;,\n    age: 25,\n    gender: &#39;male&#39;\n&#125;;\n\n// index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string     index type &#39;string&#39;.\n// index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age:     number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.\n//   Index signatures are incompatible.\n//     Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.\n//       Type &#39;number&#39; is not assignable to type &#39;string&#39;.\n</code></pre>\n<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>\n<p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p>\n<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><p>有时候希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p>\n<pre><code>nterface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n    id: 89757,\n    name: &#39;Tom&#39;,\n    gender: &#39;male&#39;\n&#125;;\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-    only property\n</code></pre>\n<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>\n<p>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</p>\n<pre><code>interface Person &#123;\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n&#125;\n\nlet tom: Person = &#123;\n    name: &#39;Tom&#39;,\n   gender: &#39;male&#39;\n&#125;;\n\ntom.id = 89757;\n\n// index.ts(8,5): error TS2322: Type &#39;&#123; name: string; gender: string; &#125;&#39; is not assignable     to type &#39;Person&#39;.\n//   Property &#39;id&#39; is missing in type &#39;&#123; name: string; gender: string; &#125;&#39;.\n// index.ts(13,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-    only property.\n</code></pre>\n<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>\n<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>类型断言<code>（Type Assertion）</code>可以用来手动指定一个值的类型。</p>\n<p>语法</p>\n<pre><code>&lt;类型&gt;值\n    或\n值 as 类型\n</code></pre>\n<p>在 <code>tsx</code> 语法（<code>React</code> 的 <code>jsx</code> 语法的 <code>ts</code> 版）中必须用后一种。</p>\n<p>例子：将一个联合类型的变量指定为一个更加具体的类型</p>\n<p>当 <code>TypeScript</code> 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法：</p>\n<pre><code>function getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n//   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n</code></pre>\n<p>而有时候，确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如：</p>\n<pre><code>function getLength(something: string | number): number &#123;\n    if (something.length) &#123;\n        return something.length;\n    &#125; else &#123;\n        return something.toString().length;\n    &#125;\n&#125;\n\n// index.ts(2,19): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n//   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n// index.ts(3,26): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n//   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n</code></pre>\n<p>上例中，获取 <code>something.length</code> 的时候会报错。</p>\n<p>此时可以使用类型断言，将 <code>something</code> 断言成 <code>string4</code>：</p>\n<pre><code>function getLength(something: string | number): number &#123;\n    if ((&lt;string&gt;something).length) &#123;\n        return (&lt;string&gt;something).length;\n    &#125; else &#123;\n        return something.toString().length;\n    &#125;\n&#125;\n</code></pre>\n<p>类型断言的用法如上，在需要断言的变量前加上 <code>&lt;Type&gt;</code> 即可。</p>\n<p>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的：</p>\n<pre><code>function toBoolean(something: string | number): boolean &#123;\n    return &lt;boolean&gt;something;\n&#125;\n\n// index.ts(2,10): error TS2352: Type &#39;string | number&#39; cannot be converted to type &#39;boolean&#39;.\n//   Type &#39;number&#39; is not comparable to type &#39;boolean&#39;.\n</code></pre>\n<h2 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h2><p><code>JavaScript</code> 中有很多内置对象，它们可以直接在 <code>TypeScript</code> 中当做定义好了的类型。<br>内置对象是指根据标准在全局作用域（<code>Global</code>）上存在的对象。这里的标准是指 <code>ECMAScript</code> 和其他环境（比如 <code>DOM</code>）的标准。</p>\n<h3 id=\"ECMAScript-的内置对象\"><a href=\"#ECMAScript-的内置对象\" class=\"headerlink\" title=\"ECMAScript 的内置对象\"></a>ECMAScript 的内置对象</h3><ul>\n<li>Boolean</li>\n<li>Error</li>\n<li>Date</li>\n<li>RegExp</li>\n<li>……</li>\n</ul>\n<p>可以在 <code>TypeScript</code> 中将变量定义为这些类型：</p>\n<pre><code>let b: Boolean = new Boolean(1);\nlet e: Error = new Error(&#39;Error occurred&#39;);\nlet d: Date = new Date();\nlet r: RegExp = /[a-z]/;\n</code></pre>\n<h3 id=\"DOM-和-BOM-的内置对象\"><a href=\"#DOM-和-BOM-的内置对象\" class=\"headerlink\" title=\"DOM 和 BOM 的内置对象\"></a>DOM 和 BOM 的内置对象</h3><ul>\n<li>Document</li>\n<li>HTMLElement</li>\n<li>Event</li>\n<li>NodeList</li>\n<li>……</li>\n</ul>\n<p><code>TypeScript</code> 中会经常用到这些类型：</p>\n<pre><code>let body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);\ndocument.addEventListener(&#39;click&#39;, function(e: MouseEvent) &#123;\n  // Do something\n&#125;);\n</code></pre>\n<h3 id=\"TypeScript-核心库的定义文件\"><a href=\"#TypeScript-核心库的定义文件\" class=\"headerlink\" title=\"TypeScript 核心库的定义文件\"></a>TypeScript 核心库的定义文件</h3><p><code>TypeScript</code> 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 <code>TypeScript</code> 中的。</p>\n<p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如：</p>\n<pre><code>Math.pow(10, &#39;2&#39;);\n\n// index.ts(1,14): error TS2345: Argument of type &#39;string&#39; is not assignable to parameter     of type &#39;number&#39;\n</code></pre>\n<p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code> 的类型定义如下：</p>\n<pre><code>interface Math &#123;\n    pow(x: number, y: number): number;\n&#125;\n</code></pre>\n<p><code>DOM</code> 中的例子：</p>\n<pre><code>document.addEventListener(&#39;click&#39;, function(e) &#123;\n    console.log(e.targetCurrent);\n&#125;);\n\n// index.ts(2,17): error TS2339: Property &#39;targetCurrent&#39; does not exist on type     &#39;MouseEvent&#39;.\n</code></pre>\n<p>上面的例子中，<code>addEventListener</code> 方法是在 <code>TypeScript</code> 核心库中定义的：</p>\n<pre><code>interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;\n    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?:     boolean): void;\n&#125;\n</code></pre>\n<p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了。</p>\n<p>注意，<code>TypeScript</code> 核心库的定义中不包含 <code>Node.js</code> 部分。</p>\n<p><code>Node.js</code> 不是内置对象的一部分，如果想用 <code>TypeScript</code> 写 <code>Node.js</code>，则需要引入第三方声明文件：</p>\n<pre><code>npm install @types/node --save-dev\n</code></pre>\n","text":"TypeScriptTypeScript是由微软推出并推动的一个静态类型检查的编译型编程语言，可以完美兼容ES6的JavaScript。目前大量前端库和应用使用TS开发，已然成为前端的主流开发语言。 优势 静态编译，减少JS动态语言特性带来了的非常多的隐藏bug 类型安全检查在编...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"code","slug":"code","count":1,"path":"api/tags/code.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TypeScript\"><span class=\"toc-text\">TypeScript</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">优势</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85TypeScript\"><span class=\"toc-text\">安装TypeScript</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">编译代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%83%E5%B0%94%E5%80%BC\"><span class=\"toc-text\">布尔值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">数字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%A5%96\"><span class=\"toc-text\">元祖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#any\"><span class=\"toc-text\">any</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#void\"><span class=\"toc-text\">void</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Null-%E5%92%8C-Undefined\"><span class=\"toc-text\">Null 和 Undefined</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Object\"><span class=\"toc-text\">Object</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">枚举</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">函数的声明</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">函数表达式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E7%8A%B6\"><span class=\"toc-text\">用接口定义函数的形状</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">可选参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">参数默认值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">剩余参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">重载</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">对象的类型——接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">简单的例子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">可选属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">任意属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">只读属性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">类型断言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">内置对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ECMAScript-%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">ECMAScript 的内置对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DOM-%E5%92%8C-BOM-%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">DOM 和 BOM 的内置对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TypeScript-%E6%A0%B8%E5%BF%83%E5%BA%93%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">TypeScript 核心库的定义文件</span></a></li></ol></li></ol></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{}}